/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package io.iohk.atala.prism.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import io.iohk.atala.prism.models.AcceptCredentialOfferRequest
import io.iohk.atala.prism.models.CreateIssueCredentialRecordRequest
import io.iohk.atala.prism.models.ErrorResponse
import io.iohk.atala.prism.models.IssueCredentialRecord
import io.iohk.atala.prism.models.IssueCredentialRecordPage

import com.squareup.moshi.Json

import io.iohk.atala.prism.infrastructure.ApiClient
import io.iohk.atala.prism.infrastructure.ApiResponse
import io.iohk.atala.prism.infrastructure.ClientException
import io.iohk.atala.prism.infrastructure.ClientError
import io.iohk.atala.prism.infrastructure.ServerException
import io.iohk.atala.prism.infrastructure.ServerError
import io.iohk.atala.prism.infrastructure.MultiValueMap
import io.iohk.atala.prism.infrastructure.PartConfig
import io.iohk.atala.prism.infrastructure.RequestConfig
import io.iohk.atala.prism.infrastructure.RequestMethod
import io.iohk.atala.prism.infrastructure.ResponseType
import io.iohk.atala.prism.infrastructure.Success
import io.iohk.atala.prism.infrastructure.toMultiValue

class IssueCredentialsProtocolApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost")
        }
    }

    /**
     * As a holder, accepts a credential offer received from an issuer.
     * Accepts a credential offer received from a VC issuer and sends back a credential request.
     * @param recordId The unique identifier of the issue credential record.
     * @param acceptCredentialOfferRequest The accept credential offer request object.
     * @return IssueCredentialRecord
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun acceptCredentialOffer(recordId: kotlin.String, acceptCredentialOfferRequest: AcceptCredentialOfferRequest) : IssueCredentialRecord {
        val localVarResponse = acceptCredentialOfferWithHttpInfo(recordId = recordId, acceptCredentialOfferRequest = acceptCredentialOfferRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as IssueCredentialRecord
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * As a holder, accepts a credential offer received from an issuer.
     * Accepts a credential offer received from a VC issuer and sends back a credential request.
     * @param recordId The unique identifier of the issue credential record.
     * @param acceptCredentialOfferRequest The accept credential offer request object.
     * @return ApiResponse<IssueCredentialRecord?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun acceptCredentialOfferWithHttpInfo(recordId: kotlin.String, acceptCredentialOfferRequest: AcceptCredentialOfferRequest) : ApiResponse<IssueCredentialRecord?> {
        val localVariableConfig = acceptCredentialOfferRequestConfig(recordId = recordId, acceptCredentialOfferRequest = acceptCredentialOfferRequest)

        return request<AcceptCredentialOfferRequest, IssueCredentialRecord>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation acceptCredentialOffer
     *
     * @param recordId The unique identifier of the issue credential record.
     * @param acceptCredentialOfferRequest The accept credential offer request object.
     * @return RequestConfig
     */
    fun acceptCredentialOfferRequestConfig(recordId: kotlin.String, acceptCredentialOfferRequest: AcceptCredentialOfferRequest) : RequestConfig<AcceptCredentialOfferRequest> {
        val localVariableBody = acceptCredentialOfferRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/issue-credentials/records/{recordId}/accept-offer".replace("{"+"recordId"+"}", encodeURIComponent(recordId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * As a credential issuer, create a new credential offer to be sent to a holder.
     * Creates a new credential offer in the database
     * @param createIssueCredentialRecordRequest The credential offer object.
     * @return IssueCredentialRecord
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createCredentialOffer(createIssueCredentialRecordRequest: CreateIssueCredentialRecordRequest) : IssueCredentialRecord {
        val localVarResponse = createCredentialOfferWithHttpInfo(createIssueCredentialRecordRequest = createIssueCredentialRecordRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as IssueCredentialRecord
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * As a credential issuer, create a new credential offer to be sent to a holder.
     * Creates a new credential offer in the database
     * @param createIssueCredentialRecordRequest The credential offer object.
     * @return ApiResponse<IssueCredentialRecord?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createCredentialOfferWithHttpInfo(createIssueCredentialRecordRequest: CreateIssueCredentialRecordRequest) : ApiResponse<IssueCredentialRecord?> {
        val localVariableConfig = createCredentialOfferRequestConfig(createIssueCredentialRecordRequest = createIssueCredentialRecordRequest)

        return request<CreateIssueCredentialRecordRequest, IssueCredentialRecord>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createCredentialOffer
     *
     * @param createIssueCredentialRecordRequest The credential offer object.
     * @return RequestConfig
     */
    fun createCredentialOfferRequestConfig(createIssueCredentialRecordRequest: CreateIssueCredentialRecordRequest) : RequestConfig<CreateIssueCredentialRecordRequest> {
        val localVariableBody = createIssueCredentialRecordRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/issue-credentials/credential-offers",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Gets an existing issue credential record by its unique identifier.
     * Gets issue credential records by record id
     * @param recordId The unique identifier of the issue credential record.
     * @return IssueCredentialRecord
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getCredentialRecord(recordId: kotlin.String) : IssueCredentialRecord {
        val localVarResponse = getCredentialRecordWithHttpInfo(recordId = recordId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as IssueCredentialRecord
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Gets an existing issue credential record by its unique identifier.
     * Gets issue credential records by record id
     * @param recordId The unique identifier of the issue credential record.
     * @return ApiResponse<IssueCredentialRecord?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getCredentialRecordWithHttpInfo(recordId: kotlin.String) : ApiResponse<IssueCredentialRecord?> {
        val localVariableConfig = getCredentialRecordRequestConfig(recordId = recordId)

        return request<Unit, IssueCredentialRecord>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getCredentialRecord
     *
     * @param recordId The unique identifier of the issue credential record.
     * @return RequestConfig
     */
    fun getCredentialRecordRequestConfig(recordId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/issue-credentials/records/{recordId}".replace("{"+"recordId"+"}", encodeURIComponent(recordId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Gets the list of issue credential records.
     * Get the list of issue credential records paginated
     * @param offset  (optional)
     * @param limit  (optional)
     * @param thid The thid of a DIDComm communication. (optional)
     * @return IssueCredentialRecordPage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getCredentialRecords(offset: kotlin.Int? = null, limit: kotlin.Int? = null, thid: kotlin.String? = null) : IssueCredentialRecordPage {
        val localVarResponse = getCredentialRecordsWithHttpInfo(offset = offset, limit = limit, thid = thid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as IssueCredentialRecordPage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Gets the list of issue credential records.
     * Get the list of issue credential records paginated
     * @param offset  (optional)
     * @param limit  (optional)
     * @param thid The thid of a DIDComm communication. (optional)
     * @return ApiResponse<IssueCredentialRecordPage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getCredentialRecordsWithHttpInfo(offset: kotlin.Int?, limit: kotlin.Int?, thid: kotlin.String?) : ApiResponse<IssueCredentialRecordPage?> {
        val localVariableConfig = getCredentialRecordsRequestConfig(offset = offset, limit = limit, thid = thid)

        return request<Unit, IssueCredentialRecordPage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getCredentialRecords
     *
     * @param offset  (optional)
     * @param limit  (optional)
     * @param thid The thid of a DIDComm communication. (optional)
     * @return RequestConfig
     */
    fun getCredentialRecordsRequestConfig(offset: kotlin.Int?, limit: kotlin.Int?, thid: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (thid != null) {
                    put("thid", listOf(thid.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/issue-credentials/records",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * As an issuer, issues the verifiable credential related to the specified record.
     * Sends credential to a holder (holder DID is specified in credential as subjectDid). Credential is constructed from the credential records found by credential id.
     * @param recordId The unique identifier of the issue credential record.
     * @return IssueCredentialRecord
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun issueCredential(recordId: kotlin.String) : IssueCredentialRecord {
        val localVarResponse = issueCredentialWithHttpInfo(recordId = recordId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as IssueCredentialRecord
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * As an issuer, issues the verifiable credential related to the specified record.
     * Sends credential to a holder (holder DID is specified in credential as subjectDid). Credential is constructed from the credential records found by credential id.
     * @param recordId The unique identifier of the issue credential record.
     * @return ApiResponse<IssueCredentialRecord?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun issueCredentialWithHttpInfo(recordId: kotlin.String) : ApiResponse<IssueCredentialRecord?> {
        val localVariableConfig = issueCredentialRequestConfig(recordId = recordId)

        return request<Unit, IssueCredentialRecord>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation issueCredential
     *
     * @param recordId The unique identifier of the issue credential record.
     * @return RequestConfig
     */
    fun issueCredentialRequestConfig(recordId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/issue-credentials/records/{recordId}/issue-credential".replace("{"+"recordId"+"}", encodeURIComponent(recordId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
