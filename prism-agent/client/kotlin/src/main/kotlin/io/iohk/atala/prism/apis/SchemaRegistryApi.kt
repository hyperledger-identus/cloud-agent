/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package io.iohk.atala.prism.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import io.iohk.atala.prism.models.CredentialSchemaInput
import io.iohk.atala.prism.models.CredentialSchemaResponse
import io.iohk.atala.prism.models.CredentialSchemaResponsePage
import io.iohk.atala.prism.models.ErrorResponse

import com.squareup.moshi.Json

import io.iohk.atala.prism.infrastructure.ApiClient
import io.iohk.atala.prism.infrastructure.ApiResponse
import io.iohk.atala.prism.infrastructure.ClientException
import io.iohk.atala.prism.infrastructure.ClientError
import io.iohk.atala.prism.infrastructure.ServerException
import io.iohk.atala.prism.infrastructure.ServerError
import io.iohk.atala.prism.infrastructure.MultiValueMap
import io.iohk.atala.prism.infrastructure.PartConfig
import io.iohk.atala.prism.infrastructure.RequestConfig
import io.iohk.atala.prism.infrastructure.RequestMethod
import io.iohk.atala.prism.infrastructure.ResponseType
import io.iohk.atala.prism.infrastructure.Success
import io.iohk.atala.prism.infrastructure.toMultiValue

class SchemaRegistryApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost")
        }
    }

    /**
     * Publish new schema to the schema registry
     * Create the new credential schema record with metadata and internal JSON Schema on behalf of Cloud Agent. The credential schema will be signed by the keys of Cloud Agent and issued by the DID that corresponds to it.
     * @param credentialSchemaInput JSON object required for the credential schema creation
     * @return CredentialSchemaResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createSchema(credentialSchemaInput: CredentialSchemaInput) : CredentialSchemaResponse {
        val localVarResponse = createSchemaWithHttpInfo(credentialSchemaInput = credentialSchemaInput)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CredentialSchemaResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Publish new schema to the schema registry
     * Create the new credential schema record with metadata and internal JSON Schema on behalf of Cloud Agent. The credential schema will be signed by the keys of Cloud Agent and issued by the DID that corresponds to it.
     * @param credentialSchemaInput JSON object required for the credential schema creation
     * @return ApiResponse<CredentialSchemaResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createSchemaWithHttpInfo(credentialSchemaInput: CredentialSchemaInput) : ApiResponse<CredentialSchemaResponse?> {
        val localVariableConfig = createSchemaRequestConfig(credentialSchemaInput = credentialSchemaInput)

        return request<CredentialSchemaInput, CredentialSchemaResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createSchema
     *
     * @param credentialSchemaInput JSON object required for the credential schema creation
     * @return RequestConfig
     */
    fun createSchemaRequestConfig(credentialSchemaInput: CredentialSchemaInput) : RequestConfig<CredentialSchemaInput> {
        val localVariableBody = credentialSchemaInput
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/schema-registry/schemas",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Fetch the schema from the registry by &#x60;guid&#x60;
     * Fetch the credential schema by the unique identifier
     * @param guid Globally unique identifier of the credential schema record
     * @return CredentialSchemaResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getSchemaById(guid: java.util.UUID) : CredentialSchemaResponse {
        val localVarResponse = getSchemaByIdWithHttpInfo(guid = guid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CredentialSchemaResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Fetch the schema from the registry by &#x60;guid&#x60;
     * Fetch the credential schema by the unique identifier
     * @param guid Globally unique identifier of the credential schema record
     * @return ApiResponse<CredentialSchemaResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getSchemaByIdWithHttpInfo(guid: java.util.UUID) : ApiResponse<CredentialSchemaResponse?> {
        val localVariableConfig = getSchemaByIdRequestConfig(guid = guid)

        return request<Unit, CredentialSchemaResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getSchemaById
     *
     * @param guid Globally unique identifier of the credential schema record
     * @return RequestConfig
     */
    fun getSchemaByIdRequestConfig(guid: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/schema-registry/schemas/{guid}".replace("{"+"guid"+"}", encodeURIComponent(guid.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Lookup schemas by indexed fields
     * Lookup schemas by &#x60;author&#x60;, &#x60;name&#x60;, &#x60;tags&#x60; parameters and control the pagination by &#x60;offset&#x60; and &#x60;limit&#x60; parameters 
     * @param author  (optional)
     * @param name  (optional)
     * @param version  (optional)
     * @param tags  (optional)
     * @param offset  (optional)
     * @param limit  (optional)
     * @param order  (optional)
     * @return CredentialSchemaResponsePage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun lookupSchemasByQuery(author: kotlin.String? = null, name: kotlin.String? = null, version: kotlin.String? = null, tags: kotlin.String? = null, offset: kotlin.Int? = null, limit: kotlin.Int? = null, order: kotlin.String? = null) : CredentialSchemaResponsePage {
        val localVarResponse = lookupSchemasByQueryWithHttpInfo(author = author, name = name, version = version, tags = tags, offset = offset, limit = limit, order = order)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CredentialSchemaResponsePage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Lookup schemas by indexed fields
     * Lookup schemas by &#x60;author&#x60;, &#x60;name&#x60;, &#x60;tags&#x60; parameters and control the pagination by &#x60;offset&#x60; and &#x60;limit&#x60; parameters 
     * @param author  (optional)
     * @param name  (optional)
     * @param version  (optional)
     * @param tags  (optional)
     * @param offset  (optional)
     * @param limit  (optional)
     * @param order  (optional)
     * @return ApiResponse<CredentialSchemaResponsePage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun lookupSchemasByQueryWithHttpInfo(author: kotlin.String?, name: kotlin.String?, version: kotlin.String?, tags: kotlin.String?, offset: kotlin.Int?, limit: kotlin.Int?, order: kotlin.String?) : ApiResponse<CredentialSchemaResponsePage?> {
        val localVariableConfig = lookupSchemasByQueryRequestConfig(author = author, name = name, version = version, tags = tags, offset = offset, limit = limit, order = order)

        return request<Unit, CredentialSchemaResponsePage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation lookupSchemasByQuery
     *
     * @param author  (optional)
     * @param name  (optional)
     * @param version  (optional)
     * @param tags  (optional)
     * @param offset  (optional)
     * @param limit  (optional)
     * @param order  (optional)
     * @return RequestConfig
     */
    fun lookupSchemasByQueryRequestConfig(author: kotlin.String?, name: kotlin.String?, version: kotlin.String?, tags: kotlin.String?, offset: kotlin.Int?, limit: kotlin.Int?, order: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (author != null) {
                    put("author", listOf(author.toString()))
                }
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (version != null) {
                    put("version", listOf(version.toString()))
                }
                if (tags != null) {
                    put("tags", listOf(tags.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (order != null) {
                    put("order", listOf(order.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/schema-registry/schemas",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Trace the request input from the point of view of the server
     * Trace the request input from the point of view of the server
     * @return kotlin.String
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun test() : kotlin.String {
        val localVarResponse = testWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.String
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Trace the request input from the point of view of the server
     * Trace the request input from the point of view of the server
     * @return ApiResponse<kotlin.String?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun testWithHttpInfo() : ApiResponse<kotlin.String?> {
        val localVariableConfig = testRequestConfig()

        return request<Unit, kotlin.String>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation test
     *
     * @return RequestConfig
     */
    fun testRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/schema-registry/test",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Publish the new version of the credential schema to the schema registry
     * Publish the new version of the credential schema record with metadata and internal JSON Schema on behalf of Cloud Agent. The credential schema will be signed by the keys of Cloud Agent and issued by the DID that corresponds to it.
     * @param author DID of the identity which authored the credential schema. A piece of Metadata.
     * @param id A locally unique identifier to address the schema. UUID is generated by the backend.
     * @param credentialSchemaInput JSON object required for the credential schema update
     * @return CredentialSchemaResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updateSchema(author: kotlin.String, id: java.util.UUID, credentialSchemaInput: CredentialSchemaInput) : CredentialSchemaResponse {
        val localVarResponse = updateSchemaWithHttpInfo(author = author, id = id, credentialSchemaInput = credentialSchemaInput)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CredentialSchemaResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Publish the new version of the credential schema to the schema registry
     * Publish the new version of the credential schema record with metadata and internal JSON Schema on behalf of Cloud Agent. The credential schema will be signed by the keys of Cloud Agent and issued by the DID that corresponds to it.
     * @param author DID of the identity which authored the credential schema. A piece of Metadata.
     * @param id A locally unique identifier to address the schema. UUID is generated by the backend.
     * @param credentialSchemaInput JSON object required for the credential schema update
     * @return ApiResponse<CredentialSchemaResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun updateSchemaWithHttpInfo(author: kotlin.String, id: java.util.UUID, credentialSchemaInput: CredentialSchemaInput) : ApiResponse<CredentialSchemaResponse?> {
        val localVariableConfig = updateSchemaRequestConfig(author = author, id = id, credentialSchemaInput = credentialSchemaInput)

        return request<CredentialSchemaInput, CredentialSchemaResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateSchema
     *
     * @param author DID of the identity which authored the credential schema. A piece of Metadata.
     * @param id A locally unique identifier to address the schema. UUID is generated by the backend.
     * @param credentialSchemaInput JSON object required for the credential schema update
     * @return RequestConfig
     */
    fun updateSchemaRequestConfig(author: kotlin.String, id: java.util.UUID, credentialSchemaInput: CredentialSchemaInput) : RequestConfig<CredentialSchemaInput> {
        val localVariableBody = credentialSchemaInput
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/schema-registry/{author}/{id}".replace("{"+"author"+"}", encodeURIComponent(author.toString())).replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
