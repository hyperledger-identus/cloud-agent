/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package io.iohk.atala.prism.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import io.iohk.atala.prism.models.ErrorResponse
import io.iohk.atala.prism.models.PresentationStatus
import io.iohk.atala.prism.models.PresentationStatusPage
import io.iohk.atala.prism.models.RequestPresentationAction
import io.iohk.atala.prism.models.RequestPresentationInput
import io.iohk.atala.prism.models.RequestPresentationOutput

import com.squareup.moshi.Json

import io.iohk.atala.prism.infrastructure.ApiClient
import io.iohk.atala.prism.infrastructure.ApiResponse
import io.iohk.atala.prism.infrastructure.ClientException
import io.iohk.atala.prism.infrastructure.ClientError
import io.iohk.atala.prism.infrastructure.ServerException
import io.iohk.atala.prism.infrastructure.ServerError
import io.iohk.atala.prism.infrastructure.MultiValueMap
import io.iohk.atala.prism.infrastructure.PartConfig
import io.iohk.atala.prism.infrastructure.RequestConfig
import io.iohk.atala.prism.infrastructure.RequestMethod
import io.iohk.atala.prism.infrastructure.ResponseType
import io.iohk.atala.prism.infrastructure.Success
import io.iohk.atala.prism.infrastructure.toMultiValue

class PresentProofApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost")
        }
    }

    /**
     * Gets the list of proof presentation records.
     * list of presentation statuses
     * @param offset  (optional)
     * @param limit  (optional)
     * @param thid  (optional)
     * @return PresentationStatusPage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAllPresentation(offset: kotlin.Int? = null, limit: kotlin.Int? = null, thid: kotlin.String? = null) : PresentationStatusPage {
        val localVarResponse = getAllPresentationWithHttpInfo(offset = offset, limit = limit, thid = thid)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PresentationStatusPage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Gets the list of proof presentation records.
     * list of presentation statuses
     * @param offset  (optional)
     * @param limit  (optional)
     * @param thid  (optional)
     * @return ApiResponse<PresentationStatusPage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getAllPresentationWithHttpInfo(offset: kotlin.Int?, limit: kotlin.Int?, thid: kotlin.String?) : ApiResponse<PresentationStatusPage?> {
        val localVariableConfig = getAllPresentationRequestConfig(offset = offset, limit = limit, thid = thid)

        return request<Unit, PresentationStatusPage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAllPresentation
     *
     * @param offset  (optional)
     * @param limit  (optional)
     * @param thid  (optional)
     * @return RequestConfig
     */
    fun getAllPresentationRequestConfig(offset: kotlin.Int?, limit: kotlin.Int?, thid: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (thid != null) {
                    put("thid", listOf(thid.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/present-proof/presentations",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Gets an existing proof presentation record by its unique identifier. More information on the error can be found in the response body.
     * Returns an existing presentation record by id.
     * @param presentationId The unique identifier of the presentation record.
     * @return PresentationStatus
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getPresentation(presentationId: java.util.UUID) : PresentationStatus {
        val localVarResponse = getPresentationWithHttpInfo(presentationId = presentationId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PresentationStatus
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Gets an existing proof presentation record by its unique identifier. More information on the error can be found in the response body.
     * Returns an existing presentation record by id.
     * @param presentationId The unique identifier of the presentation record.
     * @return ApiResponse<PresentationStatus?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getPresentationWithHttpInfo(presentationId: java.util.UUID) : ApiResponse<PresentationStatus?> {
        val localVariableConfig = getPresentationRequestConfig(presentationId = presentationId)

        return request<Unit, PresentationStatus>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getPresentation
     *
     * @param presentationId The unique identifier of the presentation record.
     * @return RequestConfig
     */
    fun getPresentationRequestConfig(presentationId: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/present-proof/presentations/{presentationId}".replace("{"+"presentationId"+"}", encodeURIComponent(presentationId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * As a Verifier, create a new proof presentation request and send it to the Prover.
     * Holder presents proof derived from the verifiable credential to verifier.
     * @param requestPresentationInput The present proof creation request.
     * @return RequestPresentationOutput
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun requestPresentation(requestPresentationInput: RequestPresentationInput) : RequestPresentationOutput {
        val localVarResponse = requestPresentationWithHttpInfo(requestPresentationInput = requestPresentationInput)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RequestPresentationOutput
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * As a Verifier, create a new proof presentation request and send it to the Prover.
     * Holder presents proof derived from the verifiable credential to verifier.
     * @param requestPresentationInput The present proof creation request.
     * @return ApiResponse<RequestPresentationOutput?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun requestPresentationWithHttpInfo(requestPresentationInput: RequestPresentationInput) : ApiResponse<RequestPresentationOutput?> {
        val localVariableConfig = requestPresentationRequestConfig(requestPresentationInput = requestPresentationInput)

        return request<RequestPresentationInput, RequestPresentationOutput>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation requestPresentation
     *
     * @param requestPresentationInput The present proof creation request.
     * @return RequestConfig
     */
    fun requestPresentationRequestConfig(requestPresentationInput: RequestPresentationInput) : RequestConfig<RequestPresentationInput> {
        val localVariableBody = requestPresentationInput
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/present-proof/presentations",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Updates the proof presentation record matching the unique identifier, with the specific action to perform.
     * Accept or reject presentation of proof request.
     * @param presentationId The unique identifier of the presentation record.
     * @param requestPresentationAction The action to perform on the proof presentation record.
     * @return PresentationStatus
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updatePresentation(presentationId: java.util.UUID, requestPresentationAction: RequestPresentationAction) : PresentationStatus {
        val localVarResponse = updatePresentationWithHttpInfo(presentationId = presentationId, requestPresentationAction = requestPresentationAction)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PresentationStatus
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Updates the proof presentation record matching the unique identifier, with the specific action to perform.
     * Accept or reject presentation of proof request.
     * @param presentationId The unique identifier of the presentation record.
     * @param requestPresentationAction The action to perform on the proof presentation record.
     * @return ApiResponse<PresentationStatus?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun updatePresentationWithHttpInfo(presentationId: java.util.UUID, requestPresentationAction: RequestPresentationAction) : ApiResponse<PresentationStatus?> {
        val localVariableConfig = updatePresentationRequestConfig(presentationId = presentationId, requestPresentationAction = requestPresentationAction)

        return request<RequestPresentationAction, PresentationStatus>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updatePresentation
     *
     * @param presentationId The unique identifier of the presentation record.
     * @param requestPresentationAction The action to perform on the proof presentation record.
     * @return RequestConfig
     */
    fun updatePresentationRequestConfig(presentationId: java.util.UUID, requestPresentationAction: RequestPresentationAction) : RequestConfig<RequestPresentationAction> {
        val localVariableBody = requestPresentationAction
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/present-proof/presentations/{presentationId}".replace("{"+"presentationId"+"}", encodeURIComponent(presentationId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
