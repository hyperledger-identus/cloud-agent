/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package io.iohk.atala.prism.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import io.iohk.atala.prism.models.ErrorResponse
import io.iohk.atala.prism.models.VerificationPolicy
import io.iohk.atala.prism.models.VerificationPolicyInput
import io.iohk.atala.prism.models.VerificationPolicyPage

import com.squareup.moshi.Json

import io.iohk.atala.prism.infrastructure.ApiClient
import io.iohk.atala.prism.infrastructure.ApiResponse
import io.iohk.atala.prism.infrastructure.ClientException
import io.iohk.atala.prism.infrastructure.ClientError
import io.iohk.atala.prism.infrastructure.ServerException
import io.iohk.atala.prism.infrastructure.ServerError
import io.iohk.atala.prism.infrastructure.MultiValueMap
import io.iohk.atala.prism.infrastructure.PartConfig
import io.iohk.atala.prism.infrastructure.RequestConfig
import io.iohk.atala.prism.infrastructure.RequestMethod
import io.iohk.atala.prism.infrastructure.ResponseType
import io.iohk.atala.prism.infrastructure.Success
import io.iohk.atala.prism.infrastructure.toMultiValue

class VerificationApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost")
        }
    }

    /**
     * Create the new verification policy
     * Create the new verification policy
     * @param verificationPolicyInput Create verification policy object
     * @return VerificationPolicy
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createVerificationPolicy(verificationPolicyInput: VerificationPolicyInput) : VerificationPolicy {
        val localVarResponse = createVerificationPolicyWithHttpInfo(verificationPolicyInput = verificationPolicyInput)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as VerificationPolicy
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Create the new verification policy
     * Create the new verification policy
     * @param verificationPolicyInput Create verification policy object
     * @return ApiResponse<VerificationPolicy?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createVerificationPolicyWithHttpInfo(verificationPolicyInput: VerificationPolicyInput) : ApiResponse<VerificationPolicy?> {
        val localVariableConfig = createVerificationPolicyRequestConfig(verificationPolicyInput = verificationPolicyInput)

        return request<VerificationPolicyInput, VerificationPolicy>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createVerificationPolicy
     *
     * @param verificationPolicyInput Create verification policy object
     * @return RequestConfig
     */
    fun createVerificationPolicyRequestConfig(verificationPolicyInput: VerificationPolicyInput) : RequestConfig<VerificationPolicyInput> {
        val localVariableBody = verificationPolicyInput
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/verification/policies",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Deleted the verification policy by id
     * Delete the verification policy by id
     * @param id Delete the verification policy by id
     * @param nonce Nonce of the previous VerificationPolicy
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteVerificationPolicyById(id: java.util.UUID, nonce: kotlin.Int) : Unit {
        val localVarResponse = deleteVerificationPolicyByIdWithHttpInfo(id = id, nonce = nonce)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Deleted the verification policy by id
     * Delete the verification policy by id
     * @param id Delete the verification policy by id
     * @param nonce Nonce of the previous VerificationPolicy
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteVerificationPolicyByIdWithHttpInfo(id: java.util.UUID, nonce: kotlin.Int) : ApiResponse<Unit?> {
        val localVariableConfig = deleteVerificationPolicyByIdRequestConfig(id = id, nonce = nonce)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteVerificationPolicyById
     *
     * @param id Delete the verification policy by id
     * @param nonce Nonce of the previous VerificationPolicy
     * @return RequestConfig
     */
    fun deleteVerificationPolicyByIdRequestConfig(id: java.util.UUID, nonce: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("nonce", listOf(nonce.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/verification/policies/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Fetch the verification policy by id
     * Get the verification policy by id
     * @param id Get the verification policy by id
     * @return VerificationPolicy
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getVerificationPolicyById(id: java.util.UUID) : VerificationPolicy {
        val localVarResponse = getVerificationPolicyByIdWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as VerificationPolicy
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Fetch the verification policy by id
     * Get the verification policy by id
     * @param id Get the verification policy by id
     * @return ApiResponse<VerificationPolicy?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getVerificationPolicyByIdWithHttpInfo(id: java.util.UUID) : ApiResponse<VerificationPolicy?> {
        val localVariableConfig = getVerificationPolicyByIdRequestConfig(id = id)

        return request<Unit, VerificationPolicy>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getVerificationPolicyById
     *
     * @param id Get the verification policy by id
     * @return RequestConfig
     */
    fun getVerificationPolicyByIdRequestConfig(id: java.util.UUID) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/verification/policies/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Lookup verification policies by query
     * Lookup verification policies by &#x60;name&#x60;, and control the pagination by &#x60;offset&#x60; and &#x60;limit&#x60; parameters
     * @param name  (optional)
     * @param offset  (optional)
     * @param limit  (optional)
     * @param order  (optional)
     * @return VerificationPolicyPage
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun lookupVerificationPoliciesByQuery(name: kotlin.String? = null, offset: kotlin.Int? = null, limit: kotlin.Int? = null, order: kotlin.String? = null) : VerificationPolicyPage {
        val localVarResponse = lookupVerificationPoliciesByQueryWithHttpInfo(name = name, offset = offset, limit = limit, order = order)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as VerificationPolicyPage
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Lookup verification policies by query
     * Lookup verification policies by &#x60;name&#x60;, and control the pagination by &#x60;offset&#x60; and &#x60;limit&#x60; parameters
     * @param name  (optional)
     * @param offset  (optional)
     * @param limit  (optional)
     * @param order  (optional)
     * @return ApiResponse<VerificationPolicyPage?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun lookupVerificationPoliciesByQueryWithHttpInfo(name: kotlin.String?, offset: kotlin.Int?, limit: kotlin.Int?, order: kotlin.String?) : ApiResponse<VerificationPolicyPage?> {
        val localVariableConfig = lookupVerificationPoliciesByQueryRequestConfig(name = name, offset = offset, limit = limit, order = order)

        return request<Unit, VerificationPolicyPage>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation lookupVerificationPoliciesByQuery
     *
     * @param name  (optional)
     * @param offset  (optional)
     * @param limit  (optional)
     * @param order  (optional)
     * @return RequestConfig
     */
    fun lookupVerificationPoliciesByQueryRequestConfig(name: kotlin.String?, offset: kotlin.Int?, limit: kotlin.Int?, order: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (order != null) {
                    put("order", listOf(order.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/verification/policies",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * Update the verification policy object by id
     * Update the verification policy entry
     * @param id 
     * @param nonce Nonce of the previous VerificationPolicy
     * @param verificationPolicyInput Update verification policy object
     * @return VerificationPolicy
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updateVerificationPolicy(id: java.util.UUID, nonce: kotlin.Int, verificationPolicyInput: VerificationPolicyInput) : VerificationPolicy {
        val localVarResponse = updateVerificationPolicyWithHttpInfo(id = id, nonce = nonce, verificationPolicyInput = verificationPolicyInput)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as VerificationPolicy
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Update the verification policy object by id
     * Update the verification policy entry
     * @param id 
     * @param nonce Nonce of the previous VerificationPolicy
     * @param verificationPolicyInput Update verification policy object
     * @return ApiResponse<VerificationPolicy?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun updateVerificationPolicyWithHttpInfo(id: java.util.UUID, nonce: kotlin.Int, verificationPolicyInput: VerificationPolicyInput) : ApiResponse<VerificationPolicy?> {
        val localVariableConfig = updateVerificationPolicyRequestConfig(id = id, nonce = nonce, verificationPolicyInput = verificationPolicyInput)

        return request<VerificationPolicyInput, VerificationPolicy>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateVerificationPolicy
     *
     * @param id 
     * @param nonce Nonce of the previous VerificationPolicy
     * @param verificationPolicyInput Update verification policy object
     * @return RequestConfig
     */
    fun updateVerificationPolicyRequestConfig(id: java.util.UUID, nonce: kotlin.Int, verificationPolicyInput: VerificationPolicyInput) : RequestConfig<VerificationPolicyInput> {
        val localVariableBody = verificationPolicyInput
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("nonce", listOf(nonce.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/verification/policies/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
